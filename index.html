<!DOCTYPE html>
<html>
    <head>
        <title>Rat Brain Simulation</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <style>
            html{
                height: 100%;
            }
            body{
                height: 100%;
                margin: 0;
            }
            #cnv{
                position: absolute;
                /*display: block;*/
            }
            #overlay{
                position: absolute;
                height: 100%;
                width: 100%;
                display: flex;
                flex-direction: column;
            }
            #toprow{
                padding: 5px;
                flex: none;
/*                width: 100%;
                display: block;*/
                background: #f0f3ff;
            }
            #panels{
                flex: auto;
                display: flex;
                overflow: hidden;
            }
            #meshpanel{
                padding: 5px;
                padding-right: 0;
                background: #F0F0FF;
                width: 200px;
                flex: none;
                display: flex;
                flex-direction: column;
                overflow-x: hidden;
                resize: horizontal;
            }
            #global{
                flex: none;
            }
            #tree{
                flex: auto;
                padding-right: 0.5em;
                overflow-x: auto;
                overflow-y: scroll;
                /*position: absolute;*/
/*                width: 150px;*/
/*                display: block;
                overflow: scroll;
                resize: horizontal;*/
            }
            #spacer{
                flex: auto;
            }
            #ptslist{
                padding: 5px;
                flex: none;
                /*position: absolute;*/
                width: 150px;
                /*display: none;*/
                /*display: block;*/
                background: #F0F0FF;
                overflow-y: scroll;
                /*resize: horizontal;*/
            }
            
            #cut_box{
                width: 370px;
                /*height: 200px;*/
                background: lightgray;
                position: absolute;
                user-select: none;
                text-align: center;
                display: none;
            }
            #cut_box>input[type=number]{
                width: 50px;
            }
            #cut_handle{
                cursor: move;
                margin-top: 5px;
                margin-bottom: -5px;
            }
            #cut_range{
                width: 90%;
            }
            
            #simple_cloud{
                position:absolute;
                user-select: none;
                width:300px;
                background:lightgray;
                text-align: center;
                display: none;
            }
            #cloud_handle{
                cursor: move;
                margin-top: 5px;
                margin-bottom: -5px;
            }
            #cloud_text{
                width:280px;
                /*height: 500px;*/
                height: 50vh;
            }
            
            ul{
                padding-left: 1em;
                list-style-type: none;
            }
            li{
                position: relative;
                /*padding-left: 2em;*/
/*                list-style-position: outside;
                text-indent: -3em;*/
            }
            .litem{
                white-space: nowrap;
            }
            li.leaf::before{
                content: "o";
                position:absolute;
                left:-1em;
                top:3px;
            }
            li.open::before{
                content: "v";
                position:absolute;
                left:-1em;
                top:3px;
            }
            li.closed::before{
                content: ">";
                position:absolute;
                left:-1em;
                top:3px;
            }
            input[type=color]{
                flex: none;
                width: 1.5em;
            }
            li > span > input[type=range]{
                position:relative;
                width: 4em;
            }
            li.mesh > span > input[type=range]{
                top:2px;
            }
            li.nomesh > span > input[type=range]{
                top:3px;
            }
            td > input[type=range]{
    /*position:relative;*/
           width: 4em;
            }
            #consolediv{
                background:rgba(0,0,0,0.5);
                position:absolute;
                top:0;
                left:0;
                width:100vw;
                height:100vh;
                display:none;
            }
            #consolepre{
                background:white;
                width:600px;
                position:absolute;
                height:80vh;
                left:0;
                right:0;
                top:0;
                bottom:0;
                margin:auto;
            }



        </style>
        <script src="mesh.js"></script>
        <script src="points.js"></script>
        <script src="shaders.js"></script>
        <script src="matrix.js"></script>
        <script>
   //         var atlasroot="WHS_SD_rat_atlas_v2";
            var atlasroot="Monotonic";
            function startup(){
                drag(cut_box,cut_handle);
                drag(simple_cloud,cloud_handle);
                drawCut();
                location.search.slice(1).split("&").forEach(function(pair){
                    if(pair.length===0)return;
                    var parts=pair.split("=");
                    if(parts[0]==="atlas")atlasroot=parts[1];
                    else if(parts[0]==="cloud"){
                        autoload(parts[1]);
                    }
//                    else{
//                        var control=document.getElementById(parts[0]);
//                        switch(control.type){
//                            case "range": control.value=parts[1];break;
//                            case "checkbox": control.checked=parts[1]==="true";break;
//                        }
//                    }
                });
                init();
                var xhr=new XMLHttpRequest();
                xhr.open("GET",atlasroot+".json");
                xhr.responseType="json";
                xhr.onload=jsonready;
                xhr.send();
            }
            
            var atlas=new Map();
            var total=0;
            var loaded=0;
            function jsonready(event){
                function walk(json,list,path){
                    for(let id of path){
                        let p=atlas.get(id);
                        if(!p.children)
                            p.children=[];
                        p.children.push(json.id);
                    }
                    let node={};
                    atlas.set(json.id,node);
                    let litem=document.createElement("li");
                    let li=document.createElement("span");
                    li.className="litem";
                    litem.appendChild(li);
                    if(json.color){
                        let color=document.createElement("input");
                        node.c_color=color;
                        color.type="color";
                        color.value="#"+json.color;
                        color.oninput=redraw;
                        li.appendChild(color);
                    }
                    let range=document.createElement("input");
                    range.type="range";
                    range.value=range.max=20;
                    range.step=1;
                    range.oninput=slide;
                    li.appendChild(range);
                    node.c_visibility=range;
                    if(!json.children){
                        litem.className="leaf";
                        li.appendChild(document.createTextNode(json.name));
                    }else{
//                        li.className="junction open";
                        litem.className=json.color?"open mesh":"open nomesh";
//                        li.className=json.color?"open mesh":"open";
                        let b=document.createElement("button");
                        b.innerText=json.name;
                        b.onclick=openclose;
                        li.appendChild(b);
                        let ul=document.createElement("ul");
                        path.push(json.id);
                        for(let child of json.children)
                            walk(child,ul,path);
                        path.pop();
                        litem.appendChild(ul);
                    }
                    list.appendChild(litem);
                }
                for(let node of event.target.response)
                    walk(node,document.getElementById("tree"),[]);
                
                atlas.forEach(function(elem,idx){
                    if(elem.c_color){
                        var img=document.createElement("img");
                        img.onload=imgLoad;
                        img.src=atlasroot+"/"+idx+".png";
                        img.atlasindex=idx;
                        total++;
                    }
                });
                
                progress();
            }
            function progress(){
                document.getElementById("counter").innerHTML=loaded+"/"+total;
            }
            function openclose(event){
                let li=event.target.parentNode.parentNode;
                let cl=li.classList;
                if(!cl.replace("closed","open")){
                    cl.replace("open","closed");
//                    let os=li.getElementsByClassName("open");
//                    while(os.length>0)
//                        os.item(0).classList.replace("open","closed");
//                    let lis=li.getElementsByTagName("ul");
//                    for(let i=0;i<lis.length;i++)
//                        lis.item(i).hidden=true;;
                    li.getElementsByTagName("ul").item(0).hidden=true;
                }else{
                    li.getElementsByTagName("ul").item(0).hidden=false;
                }
            }
            function slide(event){
                let p=event.target.parentNode.parentNode;
//                if(p.classList.contains("mesh"))
//                    p.getElementsByTagName("input")[0].disabled=event.target.valueAsNumber===0;
                if(p.classList.contains("closed") || p.classList.contains("nomesh")){
                    let rs=p.getElementsByTagName("input");
                    for(let i=0;i<rs.length;i++)
                        if(rs.item(i).type==="range")
                            rs.item(i).value=event.target.value;
                }
                redraw();
            }
            
            var gl;
            var progs;
            function init(){
                var cnv=document.getElementById("cnv");
                cnv.width=window.innerWidth-1;
                cnv.height=window.innerHeight-1;
                
//                var lst=document.getElementById("ptslist");
//                lst.style.height=(window.innerHeight-lst.offsetTop-1)+"px";
//                lst.style.left=(window.innerWidth-lst.offsetWidth-1)+"px";
//                
//                lst=document.getElementById("meshlist");
//                lst.style.height=(window.innerHeight-lst.offsetTop-1)+"px";
        
                gl=cnv.getContext("webgl",{stencil:true,alpha:false/*,premultipliedAlpha:false*/});
                gl.clearColor(1,1,1,1);

                progs=buildshaders(gl);
                
                window.addEventListener("resize",resize);
            }

            var resizescheduled=false;
            function resize(){
                var cnv=document.getElementById("cnv");
                cnv.width=window.innerWidth-1;
                cnv.height=window.innerHeight-1;
                gl.viewport(0,0,cnv.width,cnv.height);
                gl.clear(gl.COLOR_BUFFER_BIT);
                if(!resizescheduled){
                    resizescheduled=true;
                    setTimeout(function(){resizescheduled=false;redraw();},500);
                }
            }
            
            function imgLoad(event){
                loaded++;
                progress();
                var img=event.target;
                var canvas=document.createElement("canvas");
                var w=img.width;
                var h=img.height;
                canvas.width=w;
                canvas.height=h;
                var ctx=canvas.getContext("2d");
                ctx.drawImage(img,0,0);
                var raw=ctx.getImageData(0,0,w,h).data;
                for(var i=0;i<w*h;i++){
                    for(var j=0;j<3;j++)
                        raw[i*3+j]=raw[i*4+j];
                }
                
                var mesh=new Mesh(raw.buffer);
                mesh.createBuffers(gl);
                
                atlas.get(img.atlasindex).mesh=mesh;

                redraw();
            }

            var orb=0;
            var bob=0;
            var mx,my;
            function mdown(event){
                mx=event.offsetX;
                my=event.offsetY;
            }
            function mup(event){
                mx=undefined;
                my=undefined;
            }
            function mout(event){
                mx=undefined;
                my=undefined;
            }
            function mmove(event){
                if(!mx)return;
                orb+=mx;
                bob+=my;
                mx=event.offsetX;
                my=event.offsetY;
                orb-=mx;
                bob-=my;
                if(bob<-90)bob=-90;
                if(bob>90)bob=90;
                redraw();
            }
            
            var points=[];
            var drawreq=false;
            function redraw(){
                if(drawreq)return;
                drawreq=true;
                requestAnimationFrame(draw);
            }
            function draw(){
                drawreq=false;
                
                var nope=true;
                var nomesh=true;
                var minx=Number.MAX_VALUE;
                var miny=Number.MAX_VALUE;
                var minz=Number.MAX_VALUE;
                var maxx=-Number.MAX_VALUE;
                var maxy=-Number.MAX_VALUE;
                var maxz=-Number.MAX_VALUE;
                atlas.forEach(function(elem){
                    if(elem.mesh){
                        nomesh=false;
                        elem.a=elem.c_visibility.valueAsNumber/20;
                        if(elem.a>0){
                            nope=false;
                            if(minx>elem.mesh.minx)minx=elem.mesh.minx;
                            if(miny>elem.mesh.miny)miny=elem.mesh.miny;
                            if(minz>elem.mesh.minz)minz=elem.mesh.minz;
                            if(maxx<elem.mesh.maxx)maxx=elem.mesh.maxx;
                            if(maxy<elem.mesh.maxy)maxy=elem.mesh.maxy;
                            if(maxz<elem.mesh.maxz)maxz=elem.mesh.maxz;
                            var c=elem.c_color.value;
                            elem.r=parseInt(c.substring(1,3),16)/255;
                            elem.g=parseInt(c.substring(3,5),16)/255;
                            elem.b=parseInt(c.substring(5,7),16)/255;
                        }
                    }
                });
                
                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                
                if(nomesh)return;
                
                var center=ident();
                
                if(!nope){
                    center[0][3]=-(maxx+minx)/2;
                    center[1][3]=-(maxy+miny)/2;
                    center[2][3]=-(maxz+minz)/2;
                }
                
                atlas.forEach(function(elem){
                    if(elem.mesh){
                        if(minx>elem.mesh.minx)minx=elem.mesh.minx;
                        if(miny>elem.mesh.miny)miny=elem.mesh.miny;
                        if(minz>elem.mesh.minz)minz=elem.mesh.minz;
                        if(maxx<elem.mesh.maxx)maxx=elem.mesh.maxx;
                        if(maxy<elem.mesh.maxy)maxy=elem.mesh.maxy;
                        if(maxz<elem.mesh.maxz)maxz=elem.mesh.maxz;
                    }
                });

                if(nope){
                    center[0][3]=-(maxx+minx)/2;
                    center[1][3]=-(maxy+miny)/2;
                    center[2][3]=-(maxz+minz)/2;
                }

                gl.enable(gl.DEPTH_TEST);
                gl.disable(gl.BLEND);
                gl.depthMask(true);
                
                var scale=ident();
                scale[0][0]=scale[1][1]=scale[2][2]=parseFloat(document.getElementById("scale").value)/Math.sqrt(Math.pow(maxx-minx,2)+Math.pow(maxy-miny,2)+Math.pow(maxz-minz,2));

                var rot=ident();
                var sorb=Math.sin(orb*Math.PI/180);
                var corb=Math.cos(orb*Math.PI/180);
                rot[0][0]=rot[1][1]=corb;
                rot[0][1]=sorb;rot[1][0]=-sorb;
                
                var bb=ident();
                var sbob=Math.sin(bob*Math.PI/180);
                var cbob=Math.cos(bob*Math.PI/180);
                bb[0][0]=bb[2][2]=cbob;
                bb[0][2]=sbob;bb[2][0]=-sbob;
                
                var snap=zero();
                snap[0][1]=-1;
                snap[1][2]=snap[2][0]=snap[3][3]=1;
                
                var aspect=ident();
                aspect[2][2]=0.1;
                if(gl.drawingBufferWidth>gl.drawingBufferHeight){
                    aspect[0][0]=gl.drawingBufferHeight/gl.drawingBufferWidth;
                }else{
                    aspect[1][1]=gl.drawingBufferWidth/gl.drawingBufferHeight;
                }
                
                var trf=mult(mult(mult(mult(mult(aspect,snap),bb),rot),scale),center);
                var flatrf=trf[0].concat(trf[1]).concat(trf[2]).concat(trf[3]);
                var nrm=mult(mult(snap,bb),rot);
                var flatnrm=nrm[0].concat(nrm[1]).concat(nrm[2]).concat(nrm[3]);

                if(!document.getElementById("cut").checked){
                    solidMesh(flatrf,flatnrm);
                    solidCloud(flatrf);
                    transparentMesh(flatrf);
                }else{
                    if(!document.getElementById("cut_cloud").checked){
                        cutMesh(flatrf,flatnrm,(maxx+minx)/2,(maxy+miny)/2,(maxz+minz)/2,maxx-minx,maxy-miny,maxz-minz);
//                        ghostMesh(flatrf,flatnrm);
                        cutSurface(flatrf,nrm,(maxx+minx)/2,(maxy+miny)/2,(maxz+minz)/2,maxx-minx,maxy-miny,maxz-minz);
                        cutCloud(flatrf,(maxx+minx)/2,(maxy+miny)/2,(maxz+minz)/2,maxx-minx,maxy-miny,maxz-minz);
                    } else {
                        solidMesh(flatrf,flatnrm);
                        cutCloud(flatrf,(maxx+minx)/2,(maxy+miny)/2,(maxz+minz)/2,maxx-minx,maxy-miny,maxz-minz);
                        transparentMesh(flatrf);
                    }
                }
            }
            
            function solidCloud(flatrf){
                if(points.length){
                    
                    var prg=progs.solidcloud;
                    gl.useProgram(prg);

                    var coords = gl.getAttribLocation(prg, "coords");
                    gl.enableVertexAttribArray(coords);

                    gl.uniformMatrix4fv(gl.getUniformLocation(prg,"alltrf"),false,flatrf);
                    gl.uniform1f(gl.getUniformLocation(prg,"pointsize"),parseFloat(document.getElementById("psize").value));
                    
                    var color=gl.getUniformLocation(prg,"color");
                    points.forEach(function(elem){
                        if(elem.enabled && elem.a===1 && elem.count>0){
                            gl.uniform4f(color,elem.r,elem.g,elem.b,1);
                            elem.drawArray(gl,coords);
                        }
                    });
                    gl.depthMask(false);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
                    points.forEach(function(elem){
                        if(elem.enabled && elem.a!==1 && elem.count>0){
                            gl.uniform4f(color,elem.r,elem.g,elem.b,elem.a);
                            elem.drawArray(gl,coords);
                        }
                    });
                    gl.depthMask(true);
                    gl.disable(gl.BLEND);
                }
            }
            
            function cutCloud(flatrf,cx,cy,cz,sx,sy,sz){
                if(points.length){
                    
                    var prg=progs.cutcloud;
                    gl.useProgram(prg);

                    var coords = gl.getAttribLocation(prg, "coords");
                    gl.enableVertexAttribArray(coords);

                    gl.uniformMatrix4fv(gl.getUniformLocation(prg,"alltrf"),false,flatrf);
                    gl.uniform1f(gl.getUniformLocation(prg,"pointsize"),parseFloat(document.getElementById("psize").value));
                    
//                    var bob=parseFloat(document.getElementById("cutv").value)*Math.PI/180;
//                    var cutnormal=[0,Math.cos(bob),Math.sin(bob),1];
//                    var rot=parseFloat(document.getElementById("cuth").value)*Math.PI/180;
//                    var srot=Math.sin(rot);
//                    var crot=Math.cos(rot);
//                    rot=ident();
//                    rot[0][0]=rot[1][1]=crot;
//                    rot[0][1]=srot;rot[1][0]=-srot;
//                    cutnormal=mult([cutnormal],rot)[0];
//                    
//                    var pos=-parseFloat(document.getElementById("cutp").value)*Math.sqrt(sx*sx+sy*sy+sz*sz)/200;
                    var cnp=collectCut(sx,sy,sz);
                    var cutnormal=cnp.cutnormal;
                    var pos=cnp.pos;
                    
                    gl.uniform3f(gl.getUniformLocation(prg,"cutbase"),cx+cutnormal[0]*pos,cy+cutnormal[1]*pos,cz+cutnormal[2]*pos);
                    gl.uniform3fv(gl.getUniformLocation(prg,"cutnormal"),cutnormal.slice(0,3));
                
                    var color=gl.getUniformLocation(prg,"color");
                    points.forEach(function(elem){
                        if(elem.enabled && elem.a===1 && elem.count>0){
                            gl.uniform4f(color,elem.r,elem.g,elem.b,1);
                            elem.drawArray(gl,coords);
                        }
                    });
                    
                    gl.depthMask(false);
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
                    points.forEach(function(elem){
                        if(elem.enabled && elem.a!==1 && elem.count>0){
                            gl.uniform4f(color,elem.r,elem.g,elem.b,elem.a);
                            elem.drawArray(gl,coords);
                        }
                    });
                    gl.depthMask(true);
                    gl.disable(gl.BLEND);
                }
            }
            
            function solidMesh(flatrf,flatnrm){
                var prg=progs.solidmesh;
                gl.useProgram(prg);
        
                gl.uniformMatrix4fv(gl.getUniformLocation(prg,"alltrf"),false,flatrf);
                gl.uniformMatrix4fv(gl.getUniformLocation(prg,"normtrf"),false,flatnrm);
 
                var coords = gl.getAttribLocation(prg, "coords");
                gl.enableVertexAttribArray(coords);
                var normals = gl.getAttribLocation(prg, "normals");
                gl.enableVertexAttribArray(normals);
                
                var color=gl.getUniformLocation(prg,"color");
                
                gl.depthMask(true);
                
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
                atlas.forEach(function(elem){
                    if(elem.mesh && elem.a===1){
                        gl.uniform3f(color,elem.r,elem.g,elem.b);
                        elem.mesh.drawElements(gl,coords,normals);
                    }
                });
            }
            function cutMesh(flatrf,flatnrm,cx,cy,cz,sx,sy,sz){
                var prg=progs.cutmesh;
                gl.useProgram(prg);
        
                gl.uniformMatrix4fv(gl.getUniformLocation(prg,"alltrf"),false,flatrf);
                gl.uniformMatrix4fv(gl.getUniformLocation(prg,"normtrf"),false,flatnrm);
                
//                var bob=parseFloat(document.getElementById("cutv").value)*Math.PI/180;
//                var cutnormal=[0,Math.cos(bob),Math.sin(bob),1];
//                var rot=parseFloat(document.getElementById("cuth").value)*Math.PI/180;
//                var srot=Math.sin(rot);
//                var crot=Math.cos(rot);
//                rot=ident();
//                rot[0][0]=rot[1][1]=crot;
//                rot[0][1]=srot;rot[1][0]=-srot;
//                cutnormal=mult([cutnormal],rot)[0];
//                
//                var pos=-parseFloat(document.getElementById("cutp").value)*Math.sqrt(sx*sx+sy*sy+sz*sz)/200;

                var cnp=collectCut(sx,sy,sz);
                var cutnormal=cnp.cutnormal;
                var pos=cnp.pos;

                gl.uniform3f(gl.getUniformLocation(prg,"cutbase"),cx+cutnormal[0]*pos,cy+cutnormal[1]*pos,cz+cutnormal[2]*pos);
                gl.uniform3fv(gl.getUniformLocation(prg,"cutnormal"),cutnormal.slice(0,3));
 
                var coords = gl.getAttribLocation(prg, "coords");
                gl.enableVertexAttribArray(coords);
                var normals = gl.getAttribLocation(prg, "normals");
                gl.enableVertexAttribArray(normals);
                
                var color=gl.getUniformLocation(prg,"color");
                
                gl.depthMask(true);
                
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
                atlas.forEach(function(elem){
                    if(elem.mesh && elem.a===1){
                        gl.uniform3f(color,elem.r,elem.g,elem.b);
                        elem.mesh.drawElements(gl,coords,normals);
                    }
                });
            }
            function cutSurface(flatrf,nrm,cx,cy,cz,sx,sy,sz){
                var prg=progs.cutsurface;
                gl.useProgram(prg);
        
                gl.uniformMatrix4fv(gl.getUniformLocation(prg,"alltrf"),false,flatrf);
                
//                var bob=parseFloat(document.getElementById("cutv").value)*Math.PI/180;
//                var cutnormal=[0,Math.cos(bob),Math.sin(bob),1];
//                var rot=parseFloat(document.getElementById("cuth").value)*Math.PI/180;
//                var srot=Math.sin(rot);
//                var crot=Math.cos(rot);
//                rot=ident();
//                rot[0][0]=rot[1][1]=crot;
//                rot[0][1]=srot;rot[1][0]=-srot;
//                cutnormal=mult([cutnormal],rot)[0];

                var cnp=collectCut(sx,sy,sz);
                var cutnormal=cnp.cutnormal;
                var pos=cnp.pos;

                var tmp=mult([cutnormal],inv4x4(nrm))[0];
                if(tmp[2]>0)return;
                
//                var pos=-parseFloat(document.getElementById("cutp").value)*Math.sqrt(sx*sx+sy*sy+sz*sz)/200;
                gl.uniform3f(gl.getUniformLocation(prg,"cutbase"),cx+cutnormal[0]*pos,cy+cutnormal[1]*pos,cz+cutnormal[2]*pos);
                gl.uniform3fv(gl.getUniformLocation(prg,"cutnormal"),cutnormal.slice(0,3));
 
                var coords = gl.getAttribLocation(prg, "coords");
                gl.enableVertexAttribArray(coords);
//                var normals = gl.getAttribLocation(prg, "normals");
//                gl.enableVertexAttribArray(normals);
                
                var color=gl.getUniformLocation(prg,"color");
                
                gl.clear(gl.DEPTH_BUFFER_BIT);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.STENCIL_TEST);
                gl.stencilMask(1);
                
                atlas.forEach(function(elem){
                    if(elem.mesh && elem.a===1){
                        gl.uniform3f(color,elem.r,elem.g,elem.b);
                        
                        gl.clear(gl.STENCIL_BUFFER_BIT);
                        gl.colorMask(false,false,false,false);
                        gl.disable(gl.DEPTH_TEST);
                        gl.stencilFunc(gl.ALWAYS,1,1);
                        gl.stencilOp(gl.INVERT,gl.INVERT,gl.INVERT);
                        elem.mesh.drawElements(gl,coords);
                        
                        gl.colorMask(true,true,true,true);
                        gl.enable(gl.DEPTH_TEST);
                        gl.stencilFunc(gl.EQUAL,1,1);
                        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);
                        elem.mesh.drawElements(gl,coords);
                    }
                });
                gl.enable(gl.CULL_FACE);
                gl.disable(gl.STENCIL_TEST);
                
            }
//            function ghostMesh(flatrf,flatnrm){
//                var prg=progs.ghostmesh;
//                gl.useProgram(prg);
//        
//                gl.uniformMatrix4fv(gl.getUniformLocation(prg,"alltrf"),false,flatrf);
//                gl.uniformMatrix4fv(gl.getUniformLocation(prg,"normtrf"),false,flatnrm);
// 
//                var coords = gl.getAttribLocation(prg, "coords");
//                gl.enableVertexAttribArray(coords);
//                var normals = gl.getAttribLocation(prg, "normals");
//                gl.enableVertexAttribArray(normals);
//                
//                gl.enable(gl.BLEND);
//                gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
//                gl.depthMask(false);
//
//                var color=gl.getUniformLocation(prg,"color");
//                
//                gl.enable(gl.CULL_FACE);
//                gl.cullFace(gl.FRONT);
//                atlas.forEach(function(elem){
//                    if(elem.mesh && elem.enabled && elem.transparent){
//                        gl.uniform3f(color,elem.r/255,elem.g/255,elem.b/255);
//                        elem.mesh.drawElements(gl,coords,normals);
//                    }
//                });
//                gl.cullFace(gl.BACK);
//                atlas.forEach(function(elem){
//                    if(elem.mesh && elem.enabled && elem.transparent){
//                        gl.uniform3f(color,elem.r/255,elem.g/255,elem.b/255);
//                        elem.mesh.drawElements(gl,coords,normals);
//                    }
//                });
//                
//                gl.depthMask(true);
//                gl.disable(gl.BLEND);
//            }
            
            function transparentMesh(flatrf){
                var prg=progs.transparentmesh;
                gl.useProgram(prg);
        
                gl.uniformMatrix4fv(gl.getUniformLocation(prg,"alltrf"),false,flatrf);
 
                var coords = gl.getAttribLocation(prg, "coords");
                gl.enableVertexAttribArray(coords);
                
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
                gl.depthMask(false);

                var color=gl.getUniformLocation(prg,"color");
                
//                var f=0.05;
                var a=0.5;
                
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT);
                atlas.forEach(function(elem){
                    var f=elem.a;
                    if(elem.mesh && f>0 && f<1){
//                        gl.uniform4f(color,elem.r/255,elem.g/255,elem.b/255,f);
//                        gl.uniform4f(color,elem.r/255*f,elem.g/255*f,elem.b/255*f,f);
                        gl.uniform4f(color,elem.r*(a+f),elem.g*(a+f),elem.b*(a+f),f);
                        elem.mesh.drawElements(gl,coords);
                    }
                });
                gl.cullFace(gl.BACK);
                atlas.forEach(function(elem){
                    var f=elem.a;
                    if(elem.mesh && f>0 && f<1){
//                        gl.uniform4f(color,elem.r/255,elem.g/255,elem.b/255,f);
//                        gl.uniform4f(color,elem.r/255*f,elem.g/255*f,elem.b/255*f,f);
                        gl.uniform4f(color,elem.r*(a+f),elem.g*(a+f),elem.b*(a+f),f);
                        elem.mesh.drawElements(gl,coords);
                    }
                });
                
                gl.depthMask(true);
                gl.disable(gl.BLEND);
            }
            
//            function loadfile(event)
//            {
//                var fr=new FileReader();
//                fr.onload=function(){
//                    var data=JSON.parse(fr.result);
//                    points=[];
//                    var table=null;
//                    data.forEach(function(elem,idx){
//                        if(table===null)table="<table><tr><td><button onclick='showall()'>Show all</button></td><td><button onclick='hideall()'>Hide all</button></td></tr>";
//                        table+="<tr><td><input type='checkbox' checked='true' id='c"+idx+"' onchange='toggle("+idx+")'></td><td>"+elem.name+"</td></tr>";
//                        var pts=new Points(elem);
//                        pts.createBuffer(gl);
//                        points.push(pts);
//                    });
//                    if(table!==null){
//                        table+="</table>";
//                        document.getElementById("ptslist").innerHTML=table;
//                    }
//                    redraw();
//                };
//                fr.readAsText(event.target.files[0]);
//            }
            function autoload(url){
                var xhr=new XMLHttpRequest();
                xhr.open("GET",url);
                xhr.responseType="json";
                xhr.onload=function(){
                    var data=xhr.response;
                    var table=points.length>0?document.getElementById("ptstable").innerHTML:
                            "<tr><td><button onclick='showall()'>Show all</button></td><td><button onclick='hideall()'>Hide all</button></td></tr>";
                    table+="<tr><td colspan='2' style='background-color:lightgray'>"+url+"</td></tr>";
                    data.forEach(function(elem){
                        var idx=points.length;
                        table+="<tr><td><input type='checkbox' checked='true' id='c"+idx+"' onchange='toggle("+idx+")'></td><td>"+elem.name+"</td></tr>";
                        elem.r/=255;elem.g/=255;elem.b/=255;
                        var pts=new Points(elem);
                        pts.createBuffer(gl);
                        points.push(pts);
                    });
                    document.getElementById("ptstable").innerHTML=table;
                    redraw();
                };
                xhr.send();
            }
            function loadfile(event)
            {
                var fr=new FileReader();
                fr.onload=function(){
                    var data=JSON.parse(fr.result);
                    var table=points.length>0?document.getElementById("ptstable").innerHTML:
                            "<tr><td><button onclick='showall()'>Show all</button></td><td><button onclick='hideall()'>Hide all</button></td></tr>";
                    table+="<tr><td colspan='2' style='background-color:lightgray'>"+event.target.files[0].name+"</td></tr>";
                    data.forEach(function(elem){
                        var idx=points.length;
                        table+="<tr><td><input type='checkbox' checked='true' id='c"+idx+"' onchange='toggle("+idx+")'></td><td>"+elem.name+"</td></tr>";
                        elem.r/=255;elem.g/=255;elem.b/=255;
                        var pts=new Points(elem);
                        pts.createBuffer(gl);
                        points.push(pts);
                    });
                    document.getElementById("ptstable").innerHTML=table;
                    redraw();
                };
                fr.readAsText(event.target.files[0]);
            }
            function showall(){
                for(var i=0;i<points.length;i++){
                    points[i].enabled=true;
                    document.getElementById("c"+i).checked=true;
                }
                redraw();
            }
            function hideall(){
                for(var i=0;i<points.length;i++){
                    points[i].enabled=false;
                    document.getElementById("c"+i).checked=false;
                }
                redraw();
            }
            function toggle(idx){
                points[idx].enabled=document.getElementById("c"+idx).checked;
                redraw();
            }
            
//            function meshtable(){
//                function hex(x){
//                    return ("0"+x.toString(16)).slice(-2);
//                }
////                var table="<table><tr>"+
////                        "<td colspan='3'><button onclick='meshshowall()'>Show</button><br>"+
////                        "<button onclick='meshtranall()'>Transparent</button><br>"+
////                        "<button onclick='meshhideall()'>Hide</button></td>"+
////                        "</tr>";
//                var table="<table>";
//                atlas.forEach(function(elem,idx){
////                    table+="<tr>"+
////                            "<td><input type='checkbox' checked id='m"+idx+"' onchange='mtoggle("+idx+")'></td>"+
////                            "<td><input type='checkbox' id='t"+idx+"' onchange='ttoggle("+idx+")'></td>"+
////                            "<td>"+elem.name+"</td>"+
////                            "</tr>";
//                    table+="<tr>"+
//                            "<td><input type='color' id='c"+idx+"' value='#"+hex(elem.r)+hex(elem.g)+hex(elem.b)+"' oninput='cchange("+idx+")' style='width:20px'></td>"+
//                            "<td><input type='range' id='v"+idx+"' min='0' max='20' value='20' oninput='vchange("+idx+")' style='width:50px'></td>"+
//                            "<td>"+elem.name+"</td>"+
//                            "</tr>";
////                    elem.enabled=true;
////                    elem.transparent=false;
//                    elem.visibility=1;
//                });
//                table+="</table>";
//                document.getElementById("meshlist").innerHTML=table;
//            }
//            function meshshowall(){
//                for(var i=0;i<atlas.length;i++){
//                    atlas[i].visibility=1;
//                    document.getElementById("v"+i).value=20;
////                    atlas[i].enabled=true;
////                    atlas[i].transparent=false;
////                    document.getElementById("m"+i).checked=true;
////                    document.getElementById("t"+i).checked=false;
//                }
//                redraw();
//            }
//            function meshtranall(){
//                for(var i=0;i<atlas.length;i++){
//                    atlas[i].visibility=0.05;
//                    document.getElementById("v"+i).value=1;
////                    atlas[i].enabled=true;
////                    atlas[i].transparent=true;
////                    document.getElementById("m"+i).checked=true;
////                    document.getElementById("t"+i).checked=true;
//                }
//                redraw();
//            }
//            function meshhideall(){
//                for(var i=0;i<atlas.length;i++){
//                    atlas[i].visibility=0;
//                    document.getElementById("v"+i).value=0;
////                    atlas[i].enabled=false;
////                    atlas[i].transparent=false;
////                    document.getElementById("m"+i).checked=false;
////                    document.getElementById("t"+i).checked=false;
//                }
//                redraw();
//            }
//            function mtoggle(idx){
//                atlas[idx].enabled=document.getElementById("m"+idx).checked;
//                redraw();
//            }
//            function ttoggle(idx){
//                atlas[idx].transparent=document.getElementById("t"+idx).checked;
//                redraw();
//            }
            function cchange(idx){
                var c=document.getElementById("c"+idx).value.substring(1);
                atlas[idx].r=parseInt(c.substring(0,2),16);
                atlas[idx].g=parseInt(c.substring(2,4),16);
                atlas[idx].b=parseInt(c.substring(4,6),16);
                redraw();
            }
            function vchange(idx){
                atlas[idx].visibility=document.getElementById("v"+idx).valueAsNumber/20;
                redraw();
            }
            
            function setGlobal(event){
                var visibility=event.target.value;
                atlas.forEach(function(elem){
                    elem.c_visibility.value=visibility;
                });
                redraw();
            }
            
            var firstCut=true;
            function toggleCut(event){
                cut_box.style.display=event.target.checked?"block":"none";
                if(firstCut){
                    cut_box.style.left=document.getElementById("meshpanel").offsetWidth+"px";
                    cut_box.style.top=document.getElementById("meshpanel").offsetTop+"px";
                }
                firstCut=false;
                redraw();
            }
            function drag(target,handle){
                handle.addEventListener("mousedown",mdown,true);
                var pick;
                function mdown(event){
                    pick=[event.clientX,event.clientY];
                    document.addEventListener("mouseup",mup,true);
//                    document.addEventListener("mouseout",mup,true);
                    document.addEventListener("mousemove",mmove,true);
                }
                function mup(event){
                    document.removeEventListener("mouseup",mup,true);
//                    document.removeEventListener("mouseout",mup,true);
                    document.removeEventListener("mousemove",mmove,true);
                }
                function mmove(event){
                    target.style.left=(target.offsetLeft+event.clientX-pick[0])+"px";
                    target.style.top=(target.offsetTop+event.clientY-pick[1])+"px";
                    pick=[event.clientX,event.clientY];
                }
            }
            function drawCut(){
                var ctx=cut_cnv.getContext("2d");
                ctx.fillStyle="darkgray";
                ctx.fillRect(0,0,361,181);
                ctx.beginPath();
                ctx.rect(0,0,361,181);
                ctx.moveTo(180.5,0);
                ctx.lineTo(180.5,181);
                ctx.moveTo(0,90.5);
                ctx.lineTo(361,90.5);
                for(var i=0;i<361;i+=10){
                    ctx.moveTo(i+0.5,85.5);
                    ctx.lineTo(i+0.5,94.5);
                    ctx.moveTo(175.5,i+0.5);
                    ctx.lineTo(184.5,i+0.5);
                }
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cut_hrot.valueAsNumber+180.5,90.5-cut_vrot.valueAsNumber,5,0,Math.PI*2);
                ctx.fillStyle="red";
                ctx.fill();
            }
            var cut_down=false;
            function cut_mdown(event){
                cut_down=true;
                cut_input(event);
            }
            function cut_mup(event){
                cut_down=false;
            }
            function cut_input(event){
                switch(event.target){
                    case cut_level:
                        cut_range.value=cut_level.value;
                        break;
                    case cut_range:
                        cut_level.value=cut_range.value;
                        break;
                    case cut_cnv:
                        if(!cut_down)break;
                        cut_hrot.value=Math.max(Math.min(event.offsetX-180,180),-180);
                        cut_vrot.value=-Math.max(Math.min(event.offsetY-90,90),-90);
                    case cut_hrot:
                    case cut_vrot:
                        drawCut();
                        break;
                }
                redraw();
            }
            function collectCut(sx,sy,sz){
//                var bob=parseFloat(document.getElementById("cutv").value)*Math.PI/180;
                var bob=document.getElementById("cut_vrot").valueAsNumber*Math.PI/180;
                var cutnormal=[0,Math.cos(bob),Math.sin(bob),1];
//                var rot=parseFloat(document.getElementById("cuth").value)*Math.PI/180;
                var rot=document.getElementById("cut_hrot").value*Math.PI/180;
                var srot=Math.sin(rot);
                var crot=Math.cos(rot);
                rot=ident();
                rot[0][0]=rot[1][1]=crot;
                rot[0][1]=srot;rot[1][0]=-srot;
                cutnormal=mult([cutnormal],rot)[0];

//                var pos=-parseFloat(document.getElementById("cutp").value)*Math.sqrt(sx*sx+sy*sy+sz*sz)/200;
                var pos=-(document.getElementById("cut_level").valueAsNumber-50)*Math.sqrt(sx*sx+sy*sy+sz*sz)/100;
                
                return {cutnormal:cutnormal,pos:pos};
            }
            var firstCloud=true;
            function simple_open(){
                document.getElementById("simple_cloud").style.display="block";
                if(firstCloud){
                    simple_cloud.style.left=document.getElementById("meshpanel").offsetWidth+"px";
                    simple_cloud.style.top=document.getElementById("meshpanel").offsetTop+"px";
                }
                firstCloud=false;
            }
            function simple_close(){
                document.getElementById("cloud_text").value="";
                document.getElementById("simple_cloud").style.display="none";
            }
//                    data.forEach(function(elem){
//                        var idx=points.length;
//                        table+="<tr><td><input type='checkbox' checked='true' id='c"+idx+"' onchange='toggle("+idx+")'></td><td>"+elem.name+"</td></tr>";
//                        var pts=new Points(elem);
//                        pts.createBuffer(gl);
//                        points.push(pts);
//                    });
//                };
//                fr.readAsText(event.target.files[0]);
//            }
            function simple_add(){
                try{
                    var table=points.length>0?document.getElementById("ptstable").innerHTML:
                            "<tr><td><button onclick='showall()'>Show all</button></td><td><button onclick='hideall()'>Hide all</button></td></tr>";
                    table+="<tr><td colspan='2' style='background-color:lightgray'>"+cloud_head.value+"</td></tr>";
                    var lines=document.getElementById("cloud_text").value.split(/\r?\n/);
                    var name,r=0,g=0,b=0;
                    var batch=[];
                    function add(){
                        if(batch.length){
                            var idx=points.length;
                            if(!name)name="Cloud #"+(idx+1);
                            var pts=new Points({idx:idx,r:r,g:g,b:b,name:name,count:batch.length/3,triplets:batch});
                            pts.createBuffer(gl);
                            points.push(pts);
                            table+="<tr><td><input type='checkbox' checked='true' id='c"+idx+"' onchange='toggle("+idx+")'></td><td>"+name+"</td></tr>";
                            name=undefined;
                            batch=[];
                        }
                    }
                    lines.forEach(function(line){
                        line=line.trim();
                        var coords=line.match(/^([\d\.]+)[\s,]+([\d\.]+)[\s,]+([\d\.]+)/);
                        if(coords)coords.slice(1).forEach(function(x,i){
                            x=parseFloat(x);
                            if(i===0){
                                if(WHS_flip.checked)x=511-x;
                                else if(ABA_flip.checked)x=455-x;
                            }
                            batch.push(parseFloat(x));
                        });
                        else{
                            add();
                            var colors=line.match(/^RGB\s*([\d\.]+)[\s,]+([\d\.]+)[\s,]+([\d\.]+)/);
                            if(colors){
                                r=Math.max(0,Math.min(1,parseFloat(colors[1])));
                                g=Math.max(0,Math.min(1,parseFloat(colors[2])));
                                b=Math.max(0,Math.min(1,parseFloat(colors[3])));
                            }else
                                if(line[0]==="#")name=line.substring(1).trim();
                        }
                    });
                    add();

                    document.getElementById("ptstable").innerHTML=table;
                    redraw();
                    simple_close();
                }catch(e){
                    alert("Sum Ting Wong says: "+e);
                }
            }
        </script>
    </head>
    <body onload="startup()">
        <!--<canvas id="cnv" onmousedown="mdown(event)" onmousemove="mmove(event)" onmouseup="mup(event)" onmouseout="mout(event)"></canvas>-->
        <canvas id="cnv"></canvas>
        <div id="overlay">
            <div id="toprow">
                <label for="bgcolor">Background:</label>
                <input type="color" id="bgcolor" value="#FFFFFF" oninput="redraw()">
                <label for="scale">Scale:</label><input type="range" id="scale" min="1" max="5" value="3" oninput="redraw()">
                <input type="checkbox" id="cut" onchange="toggleCut(event)"><label for="cut">Cut</label>
                <!--| Cloud: (<a href="example.json"  >example</a>)-->
               <!-- <input type="file" accept="text/json" onchange="loadfile(event)">-->
                <!--<button onclick="simple_open()">Cloud from coordinates</button>-->
               <!-- <input type="range" id="psize" min="1" max="10" value="2" oninput="redraw()"><label for="psize">Point size</label>-->
                <div id="counter" style="display:block;float:right"></div>
            </div>
            <div id="panels">
                <div id="meshpanel">
                    <div id="global" style="display: flex">All:<input type="range" min="0" max="20" value="20" step="1" oninput="setGlobal(event)" style="width:100%"></div>
                    <!--<div id="meshlist"></div>-->
                    <ul id="tree"></ul>
                    <div>
                        <span style="float:right">Resize panel here =&gt;</span>
                    </div>
                </div>
                <div id="spacer" onmousedown="mdown(event)" onmousemove="mmove(event)" onmouseup="mup(event)" onmouseout="mout(event)"></div>
                <div id="ptslist"><table id="ptstable"></table></div>
            </div>
        </div>
        <div id="cut_box">
            <div id="cut_handle">Cut controls</div>
            <hr>
            <!--<input type="checkbox" id="cut_enable"><label for="cut_enable">Enable</label>-->
            <!--<input type="checkbox" id="cut_face"><label for="cut_face">Face</label>-->
            <label for="cut_hrot">H</label><input type="number" id="cut_hrot" step="0.05" value="0" oninput="cut_input(event)">
            <label for="cut_hrot">V</label><input type="number" id="cut_vrot" step="0.05" value="0" oninput="cut_input(event)">
            <label for="cut_level">L</label><input type="number" id="cut_level" step="0.05" min="0" max="100" value="50" oninput="cut_input(event)">
            <label for="cut_cloud">Cloud only</label><input type="checkbox" id="cut_cloud" oninput="cut_input(event)"><br>
            <!--<canvas id="cut_cnv" width="361" height="181" onmousedown="cut_mdown(event)" onmouseup="cut_mup(event)" onmouseout="cut_mup(event)" onmousemove="cut_input(event)"></canvas><br>-->
            <canvas id="cut_cnv" width="361" height="181" onmousedown="cut_mdown(event)" onmouseup="cut_mup(event)" onmousemove="cut_input(event)"></canvas><br>
            <input type="range" id="cut_range" step="0.05" min="0" max="100" oninput="cut_input(event)">
            <!--<div style="text-align: left;font-size: small">Performance of mesh cut really benefits from a discrete graphics card</div>-->
        </div>
        <div id="simple_cloud">
            <div id="cloud_handle">Coordinate listing</div>
            <hr>
            Block header:<input type="text" id="cloud_head" value="-------">
            <textarea id="cloud_text" placeholder="One x,y,z triplet per row, separated by commas or spaces."></textarea>
            Mirror x-axis
            <input type="checkbox" onclick="WHS_flip.checked=ABA_flip.checked=false;flips.style.visibility=event.target.checked?'visible':'hidden'">
            <span id="flips" style="visibility:hidden">
                <input type="checkbox" id="ABA_flip" onclick="WHS_flip.checked=false"><label for="ABA_flip">ABA</label>
                <input type="checkbox" id="WHS_flip" onclick="ABA_flip.checked=false"><label for="WHS_flip">WHS</label><br>
            </span>
            <button onclick="simple_add()">Add</button><button onclick="simple_close()">Cancel</button>
        </div>
    </body>
</html>
